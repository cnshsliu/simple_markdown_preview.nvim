'use strict';
const marked = require('marked');
const katex = require('katex');
const path = require('path');
const mime = require('mime-types');
const Hapi = require('@hapi/hapi');
const Wreck = require('@hapi/wreck');
const Cheerio = require('cheerio');
const fs = require('fs');
const plantumlEncoder = require('plantuml-encoder');

const regex_wiki = /\[\[(.*?)\]\]/g;
const regex_snippet = /^\s*{(.+)}\s*$/;
const regex_toc = /\{(:)?(toc|TOC|Toc)\}/;
const regex_a_link = /\[(.*)]\s*\((.+)\)/;
const regex_structure_tag = /\{(:)?(tags)\}/i;
const regex_structure_link = /\{(:)?(links)\}/i;
const regex_structure_backlink = /\{(:)?(backlinks)\}/i;

const copyright = `<center><br/><br/>generated by <a href="https://github.com/cnshsliu/smp.nvim">smp.nvim</a>, created by <a href="https://www.buymeacoffee.com/liukehong">LiuKeHong</a> </center>`;

let string_stores = {};
let update_key_stores = {};
let chartJs_codes = {};
// let fn_stores = {};

// let serNumber = 0;

const logFile = 'smp_server_log.txt';
let current_fn_key = '';
let global_indicator = -1;
const defaultMarkDownCss = '/styles/github-markdown.css';
const smpConfig = {
	css: defaultMarkDownCss,
	tmp: '/tmp',
	show_navigation_panel: true,
	show_navigation_content: true,
};

function findKeyByValue(obj, value) {
	const foundKey = Object.keys(obj).find((key) => obj[key] === value);
	return foundKey;
}
function ensureAbsolutePath(inputPath, currentFilePath) {
	if (path.isAbsolute(inputPath)) {
		return inputPath;
	} else {
		const currentDir = path.dirname(currentFilePath); // Get the current file's directory
		const absolutePath = path.join(currentDir, inputPath); // Create an absolute path relative to the current file's directory
		return absolutePath;
	}
}
const smp_links = {};
function generateRandomString(length) {
	let result = '';
	const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	const charactersLength = characters.length;
	for (let i = 0; i < length; i++) {
		result += characters.charAt(Math.floor(Math.random() * charactersLength));
	}
	return result;
}

//katex version: https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css
const getStylesheet = function () {
	const stylesheet = `
  <link rel="stylesheet" href="${smpConfig.css}" type="text/css">
	<link rel="stylesheet" href="/styles/highlight-github.css" type="text/css">
	<link rel="stylesheet" href="/styles/smp.css" type="text/css">
  <link rel="stylesheet" href="/styles/katex.min.css">
  <script src="/diffdom/diffDOM.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    .markdown-body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }

    @media (max-width: 767px) {
      .markdown-body {
        padding: 15px;
      }
    }
    .ball {
      width: 0;
      height: 0;
      border-right: 1rem solid red;
      margin-left: 0.5rem;
    }

  </style>
`;

	return stylesheet.replace(/\n/g, '');
};

//insert this script into the html ONCE
const getSmoothScrollScript = function (update_key, lnr, thisline, showIndicator = true) {
	thisline = thisline.replace(/`/g, '\\`');
	return `
  <script type="module">
import * as sxMxPx_x_M1e2r0mxaidJs from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
window.sxMxPx_x_M1e2r0mxaidJs = sxMxPx_x_M1e2r0mxaidJs.default;
let thisTs = 0;
let lastTs = -1;
let use_indicator=undefined;
function removeExistingBalls(){
    const ballElements = document.querySelectorAll(".ball");

    ballElements.forEach((element) => {
      element.classList.remove("ball");
    });
}

function setIndicator(linenr, lineText){
  let thisAnchor=null;
  let foundLineNr = -5;
  for(let i=linenr; i>=0; i--){
      thisAnchor = document.querySelector(\`.lucas_tkbp_\${i}\`);
      if(thisAnchor !==null){
        foundLineNr = i;
        break;
      }else{
}
  }
  if(thisAnchor !== null){
      removeExistingBalls();
      thisAnchor.classList.add("ball");
  }
  if(foundLineNr !== linenr && lineText.trim()  !==   ""){
    try{window.find(lineText)}catch(err){}
  }
}

function scrollOnly(linenr, lineText){
  linenr = linenr - 3;
  if (linenr < 1) linenr = 0;
  let thisAnchor=null;
  let foundLineNr = -3;
  for(let i=linenr; i>=0; i--){
      thisAnchor = document.querySelector(\`.scrollTo.lucas_tkbp_\${i}\`);
      if(thisAnchor !==null){
        foundLineNr = i;
        break;
      }
  }
  if(thisAnchor !== null){
      try{thisAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });}catch(err){ }
  }
}

function scrollToLine(linenr, lineText){
  if(use_indicator===undefined?${showIndicator}:use_indicator ) setIndicator(linenr, lineText);
  scrollOnly(linenr, lineText);
}

scrollToLine(${lnr}, \`${thisline}\`);



let fetchFailed = 0;
let intervalId=0;
const dd = new diffDOM.DiffDOM();
function fetchData() {
    let url = "http://127.0.0.1:3030/getupdate/${update_key}/" + thisTs;
    lastTs = thisTs;
    fetch(url)
      .then((response) => {
        return response.json();
      })
      .then((data) => {
        if(data.use_indicator !== undefined)
        {
          if(use_indicator === true && data.use_indicator === false){
              removeExistingBalls();
          }
          use_indicator = data.use_indicator;
        }
        switch(data.code){
          case 'touched_all':
            const oldElement = document.querySelector(".markdown-body");
            const newElement = oldElement.cloneNode(false);

            newElement.innerHTML = data.html;

            const diff = dd.diff(oldElement, newElement);
            dd.apply(oldElement, diff);



            requestAnimationFrame(() => {
                        setTimeout(()=>{scrollToLine(data.linenr, data.thisline);}, 200);
            });
            break;
          case 'touched_line':
            scrollToLine(data.linenr, data.thisline);
            break;
          default:
        }
        if(data.ts) {thisTs = data.ts; }
          const mermaidElement = document.querySelector('.mermaid');
          if(mermaidElement){
            window.sxMxPx_x_M1e2r0mxaidJs.initialize({startOnLoad:false});
            window.sxMxPx_x_M1e2r0mxaidJs.run({
              querySelector: '.mermaid',
              suppressErrors: true,
            }).then(()=>{
            })
          }
      })
      .catch((error) => {
        fetchFailed += 1;
        if(fetchFailed > 200){
          try{clearInterval(intervalId);}catch(err){}
        }
      });
}
intervalId = setInterval(fetchData, 500);
</script>
  `.replace(/\n/g, '');
};

const getChartJsScript = function () {
	let ids = Object.keys(chartJs_codes);
	let script = '';
	for (let i = 0; i < ids.length; i++) {
		script += `<script>const ${ids[i]} = document.getElementById('${ids[i]}');
new Chart(${ids[i]}, ${chartJs_codes[ids[i]]});</script>`;
	}
	return script;
};

function logToFile(...msgs) {
	const timestamp = new Date().toISOString();
	let message = msgs.join(' ');
	const logMessage = `${timestamp} - ${message}\n`;

	fs.appendFile(logFile, logMessage, (_) => {});
}

// Usage:
const renderer = new marked.Renderer();

// Override the 'codespan' function to handle inline math
renderer.codespan = function (text) {
	if (text.startsWith('\\(') && text.endsWith('\\)')) {
		const latex = text.slice(2, -2);
		return katex.renderToString(latex, { throwOnError: false });
	}
	return `<code>${text}</code>`;
};

const hljs = require('highlight.js');
let hl = function (code, lang) {
	const language = hljs.getLanguage(lang) ? lang : 'plaintext';
	return hljs.highlight(code, { language }).value;
};

const imagelizedLang = ['plantuml', 'math', 'chartjs', 'chart'];

function renderMermaid(mermaidCode, lineNr) {
	let svg = '';

	// Render the Mermaid code to an SVG image using a callback function
	mermaid.render('diagram_' + lineNr, mermaidCode, (result) => {
		svg = result;
	});

	// Return the SVG image as a string
	return svg;
}

renderer.code = function (code, codeLang, lineNumber) {
	// return `<pre><code class="language-${codeLang}">${code}</code></pre>`;
	if (codeLang === 'math') {
		return katex.renderToString(code, { displayMode: true, throwOnError: false });
	} else if (codeLang === 'plantuml') {
		const imageUrl = generatePlantUmlImageUrl(code);
		return `<img src="${imageUrl}"/>`;
	} else if (codeLang === 'mermaid') {
		return `<span class="mermaid">${code}</span>`;
	} else if (codeLang === 'chartjs') {
		let chartjs_canvas_id = Object.keys(chartJs_codes).length;
		chartJs_codes[`chartjs_${chartjs_canvas_id}`] = code;
		return `<div style="width: 500px;"><canvas id="chartjs_${chartjs_canvas_id}"></canvas></div>`;
	}
	return `<pre><code class="hljs language-${codeLang}">${hl(code, codeLang)}</code></pre>`;
};

class CustomLexer extends marked.Lexer {
	constructor(options) {
		super(options);
	}

	lex(src) {
		const tokens = [];
		let lineNumber = 1;

		while (src) {
			const nextToken = super.token(src, true);
			if (nextToken) {
				src = src.slice(nextToken.raw.length);

				if (nextToken.type === 'code') {
					nextToken.lineNumber = lineNumber;
				}
				lineNumber += (nextToken.raw.match(/\n/g) || []).length;

				tokens.push(nextToken);
			} else {
				src = '';
			}
		}

		return tokens;
	}
}

marked.setOptions({
	renderer: renderer,
	Lexer: CustomLexer,
	highlight: function (code, lang) {
		const hljs = require('highlight.js');
		const language = hljs.getLanguage(lang) ? lang : 'plaintext';
		return hljs.highlight(code, { language }).value;
	},
	langPrefix: 'hljs language-', // highlight.js css expects a top-level 'hljs' class.
	pedantic: false,
	gfm: true,
	breaks: false,
	sanitize: false,
	smartypants: false,
	xhtml: false,
});

function getKeyByValue(obj, value) {
	for (const key in obj) {
		if (obj[key] === value) {
			return key;
		}
	}
}

function isValidUrl(string) {
	let url;

	try {
		url = new URL(string);
	} catch (_) {
		return false;
	}

	return url.protocol === 'http:' || url.protocol === 'https:';
}

function generatePlantUmlImageUrl(plantUmlSource) {
	const encodedPlantUml = plantumlEncoder.encode(plantUmlSource);
	const plantUmlServerUrl = 'http://www.plantuml.com/plantuml/img/';
	return plantUmlServerUrl + encodedPlantUml;
}
const indicator = function (lnr, scroll = true) {
	return `<span class="${scroll ? 'scrollto' : ''} lucas_tkbp_${lnr + 1}">&nbsp;</span>`;
};

function patchAllLines(lines, dir_of_current_md, md_fn, structure) {
	let codeStart = -1;
	let codeEnd = -1;
	let patched = [];
	let pure = [];
	let codeLang = '';
	for (let i = 0; i < lines.length; i++) {
		let x = lines[i];
		pure.push(x);
		let patchedLine = patchLine(lines, lines[i], i, dir_of_current_md, md_fn, structure, true);
		patched.push(patchedLine);

		//a code block start， at the end of code block,
		//will revert any line patch, and use the original line
		//this is to avoid the line number in code block is changed
		//which will cause the line number in the code block is not correct
		//when the code block is rendered by marked
		//the code block is identified by ``` at the start and end of the block
		//the code block can be identified by the language name, e.g. ```js
		//if the code block is not identified by language name, it is treated as pure text
		if (x.match(/^\s*`/)) {
			if (codeStart < 0) {
				codeStart = i;
				let match = x.match(/```(\w*)/);
				if (match) {
					codeLang = match[1];
				} else {
					codeLang = '';
				}
			} else codeEnd = i;
			if (codeEnd > 0) {
				for (let j = codeStart; j <= codeEnd; j++) {
					patched[j] = pure[j];
				}
				//if its a supported codeLang, we will insert a indicator
				//to indicate the start and end of the code block
				if (imagelizedLang.indexOf(codeLang) >= 0) {
					//for imagelized text, no auto scroll
					//Befote the code start
					//insert a indicator after a new line mark
					patched[codeStart] = '&nbsp;' + indicator(codeStart, true) + '\n' + patched[codeStart];

					//For those markdown lines which will be converted
					//into a picture, we insert patch, only used for highlight
					//without scroll to it,
					//Why do we need no-scroll-to location? because if you are
					//editing a imagelizable mardown section which have many lines
					//or when you move cursor within this area
					//the browser will jump to this location
					//make your editing experience unstable.
					patched[codeEnd] += '\n&nbsp;' + indicator(codeStart + 1, false);
				}
				codeStart = -1;
				codeEnd = -1;
				codeLang = '';
			}
		}
	}
	return patched;
}

const getStructureFromContent = function (home, fn, markdown) {
	const links = getLinks(home, markdown);
	const tags = getTags(markdown);
	const backlinks = getBacklinks(home, path.basename(fn, '.md'));

	return { links, tags, backlinks };
};

const find_file = function (directory, file_name) {
	function search_directory(dir_path) {
		const entries = fs.readdirSync(dir_path, { withFileTypes: true });
		for (const entry of entries) {
			const entry_path = path.join(dir_path, entry.name);
			if (entry.isDirectory()) {
				const result = search_directory(entry_path);
				if (result) {
					return result;
				}
			} else if (entry.isFile() && entry.name === file_name) {
				return entry_path;
			}
		}
	}

	return search_directory(directory);
};

const find_title = function (directory, title) {
	return find_file(directory, title + '.md');
};

const getLinks = function (home, markdown) {
	const regex = /\[\[([^\]]+)\]\]/g;

	const links = [];

	for (const match of markdown.matchAll(regex)) {
		const title = match[1];
		const path = find_title(home, title);
		links.push({ title: title, fullpath: path });
	}

	return links;
};

const getTags = function (markdown) {
	const regex = /[\s"'](#\w+)/g;

	let tags = [];

	for (const match of markdown.matchAll(regex)) {
		tags.push(match[1]);
	}
	tags = [...new Set(tags)];
	return tags;
};

function getBacklinks(directory, title) {
	const regex = /\[\[([^\]]+)\]\]/g;

	console.log('getBacklinks', directory, title);

	const backlinks = [];

	function process_file(file_path) {
		console.log('Process file', file_path);
		const markdown = fs.readFileSync(file_path, 'utf8');

		for (const match of markdown.matchAll(regex)) {
			const link = match[1];
			if (link === title) {
				const file = path.basename(file_path);
				const dir = path.dirname(file_path);
				const link_path = path.relative(directory, dir) + '/' + file;
				backlinks.push({
					fullpath: path.join(directory, link_path),
					title: path.basename(file_path, '.md'),
				});
			}
		}
	}

	function process_directory(dir_path) {
		console.log('process_directory', dir_path);
		const entries = fs.readdirSync(dir_path, { withFileTypes: true });
		for (const entry of entries) {
			const entry_path = path.join(dir_path, entry.name);
			if (entry.isDirectory()) {
				process_directory(entry_path);
			} else if (entry.isFile() && entry.name.endsWith('.md')) {
				process_file(entry_path);
			}
		}
	}

	process_directory(directory);

	return backlinks;
}

const getNavigationUrl = function (fn, ispreview, section) {
	return (
		'http://127.0.0.1:3030/nav?path=' +
		encodeURIComponent(fn) +
		'&section=' +
		section +
		'&from=' +
		(ispreview ? 'preview' : 'zettel')
	);
};

const getZettelPath = function (fn) {
	return `http://127.0.0.1:3030/zettel?path=${encodeURIComponent(fn)}`;
};
const getTagHref = function (tag, fn) {
	return `http://127.0.0.1:3030/tag?tag=${encodeURIComponent(tag)}&path=${encodeURIComponent(fn)}`;
};

const getNavigationDiv = function (fn, ispreview) {
	if (smpConfig.show_navigation_panel === false) return '';

	const ret = `
    <div id="smp_nav_panel" class="">
		  <div><a href="#" onclick="editThis(event, '${fn}');">Edit</a></div>
      <div><a href="#" onclick="hideNavigation(event)">Hide</a></div>
    </div>
    <script>
      let printing = false;
      const onPrint = async function () {
        printing = true;
        document.getElementById('smp_nav_container')?.classList.add('noshow');
        document.getElementById('smp_nav_panel').classList.add('noshow');
        setTimeout(async () => {
          document.getElementById('smp_nav_container')?.classList.remove('noshow');
          document.getElementById('smp_nav_panel').classList.remove('noshow');
          printing = false;
        }, 3000);
      };
      async function print(event){
          onPrint().then(()=>{
            window.print();
          });
      }
      function hideNavigation(event){
          event.preventDefault();
          document.getElementById('smp_nav_container')?.classList.add('noshow');
          document.getElementById('smp_nav_panel').classList.add('noshow');
      }
      function editThis(event, path){
        event.preventDefault(); 
        console.log(path);
        fetch("http://127.0.0.1:3030/editThis?path=" + encodeURIComponent(path))
      }
    </script>
    <style>
      #smp_nav_panel{
        position: fixed; right: 10px;
        bottom: 10px;
        border-radius: 10px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        padding: 1rem;
      }
      .noshow{
        display:none;
      }
      .smp_nav_tag, .smp_nav_link, .smp_nav_backlink{
        padding: 3px; border:1px solid; border-radius:5px; margin-right: 5px; margin-bottom: 5px;
      }
  </style>
`;
	return ret;
};
const generateTOC = function (markdownLines) {
	const toc = [];
	const headerRegex = /^(#{1,6})\s+(.+)$/;

	markdownLines.forEach((line, index) => {
		const match = line.match(headerRegex);
		if (match) {
			const level = match[1].length;
			const title = match[2].trim();
			const anchor = title
				.toLowerCase()
				.replace(/[^a-z0-9\s]/g, '')
				.replace(/\s+/g, '-');
			toc.push({ level, title, anchor, lineNumber: index + 1 });
		}
	});

	return toc;
};

const generateTOCHTML = function (toc) {
	let html = '<div class="smp-toc"><ul>';
	let previousLevel = 1;

	for (let i = 0; i < toc.length; i++) {
		const currentItem = toc[i];
		const nextItem = toc[i + 1];

		html += `<li><a href="#${currentItem.anchor}">${currentItem.title}</a></li>`;

		if (nextItem) {
			const levelDifference = nextItem.level - currentItem.level;
			if (levelDifference > 0) {
				html += '<ul>';
			} else if (levelDifference < 0) {
				html += '</ul>'.repeat(-levelDifference);
			}
			previousLevel = currentItem.level;
		}
	}

	html += '</ul>'.repeat(previousLevel);
	html += '</div>';

	return html;
};

const patchLine = (
	allLines,
	line,
	lnr,
	dir_of_current_md,
	md_fn,
	structure,
	appendIndicator = true,
) => {
	//
	//Reference , don't touch
	if (line.match(/^\s*\[.+]:\s*.+$/)) {
		//Refen
		appendIndicator = false;
	} else if (line.match(/^\s*$/)) {
		//Patch bank line
		//Blank like, don't touch
		appendIndicator = appendIndicator;
		return '';
	} else if (line.match(regex_toc)) {
		const toc = generateTOC(allLines);
		logToFile(JSON.stringify(toc));
		line = generateTOCHTML(toc);
		logToFile(line);
	} else if (line.match(regex_structure_tag)) {
		let tags_html_without_header = '<div class="smp_structure_tags">';
		for (const tag of structure.tags) {
			tags_html_without_header += `<span class="smp_nav_tag"><a href="${getTagHref(
				tag,
				md_fn,
			)}">${tag}</a></span>`;
		}
		tags_html_without_header += '</div>';
		line = tags_html_without_header;
	} else if (line.match(regex_structure_link)) {
		let links_html = '<div class="smp_structure_links">';
		for (const link of structure.links) {
			links_html += `<span class="smp_nav_link"><a href="${getZettelPath(link.fullpath)}">${
				link.title
			}</a></span>`;
		}
		links_html += '</div>';
		line = links_html;
	} else if (line.match(regex_structure_backlink)) {
		let backlinks_html = '<div class="smp_structure_backlinks">';
		for (const link of structure.backlinks) {
			backlinks_html += `<span class="smp_nav_backlinks"><a href="${getZettelPath(
				link.fullpath,
			)}">${link.title}</a></span>`;
		}
		backlinks_html += '</div>';
		line = backlinks_html;
	} else if (line.match(regex_snippet)) {
		let m = line.match(regex_snippet);
		let snippetName = m[1].trim();
		function parse_snippet_content(snippet, level = 0) {
			//stop parse if level > 9
			if (level > 9) return null;
			if (!(smpConfig && smpConfig.snippets_folder)) {
				logToFile('smpConfig.snippets_folder is not defined');
				return null;
			}
			let fullPath = path.resolve(smpConfig.snippets_folder, snippet + '.md');
			if (fs.existsSync(fullPath)) {
				let content = fs.readFileSync(fullPath, 'utf8');
				let lines = content.split('\n');
				let foundChildSnippet = false;
				let retContentLines = [];
				for (let i = 0; i < lines.length; i++) {
					if (lines[i].match(regex_snippet)) {
						foundChildSnippet = true;
						let m = lines[i].match(regex_snippet);
						let childSnippetName = m[1].trim();
						retContentLines.push(parse_snippet_content(childSnippetName, level + 1) || lines[i]);
					} else {
						retContentLines.push(lines[i]);
					}
				}
				return retContentLines.join('\n') + '\n';
			} else {
				return null;
			}
		}
		if (snippetName) line = parse_snippet_content(snippetName, 0) || line;
	} else if (line.match(/\[\[.+]]/)) {
		//Patch WIKI link
		//Wiki link, a bit more complicated
		//I use this syntax heavily in Telekasten
		let outputString = line.replace(regex_wiki, (match, p1) => {
			let fullPath = path.resolve(dir_of_current_md, p1.match(/^.+\.(.+)$/) ? p1 : p1 + '.md');
			// const fullPath = path.resolve(p1);
			// const fileName = path.basename(p1);
			const fileExists = fs.existsSync(fullPath);
			if (fileExists) {
				// let myKey = getKeyByValue(fn_stores, fullPath);
				let myKey = encodeURIComponent(fullPath);
				//Give it 'zettel' class, so the display style of zettel can be easily customized later
				return `<span class="zettel"><a href="/zettel?path=${myKey}">${p1}</a></span>`;
			} else {
				//also highlight missing zettel file
				return `<span class="notfound">${p1}</span>`;
			}
		});
		// logToFile('convert ' + line + ' to ' + outputString);
		line = outputString;
	} else if (line.match(regex_a_link)) {
		//Patch local MD link
		//如果是 [name](link) 方式
		let outputString = line.replace(regex_a_link, (match, p1, p2) => {
			if (isValidUrl(p2)) {
				//if link is valid url, return normal Markdown link
				return `[${p1}](${p2})`;
			} else if (p2.startsWith('#')) {
				return `[${p1}](${p2})`;
			} else {
				//if a wiki style link to a local file
				//convert it to SMP_LINK handler
				const fullpath = path.resolve(dir_of_current_md, p2);
				return `[${p1}](/zettel?path=${encodeURIComponent(fullpath)})`;
			}
		});
		// logToFile(`Replace [${line}] to [${outputString}]`);
		line = outputString;
	}
	return appendIndicator ? `${line}${indicator(lnr)}` : line;
};

function search_tag_in_directory(directory, tags_to_match, tags_to_exclude) {
	const regex = /(?:^|\s+|['"])\s*(#[\p{L}0-9_]+)(?=$|\s|['"])/gu;
	const matches = [];

	const entries = fs.readdirSync(directory, { withFileTypes: true });
	for (const entry of entries) {
		const entry_path = path.join(directory, entry.name);
		if (entry.isDirectory()) {
			matches.push(...search_tag_in_directory(entry_path, tags_to_match, tags_to_exclude));
		} else if (entry.isFile() && entry_path.endsWith('.md')) {
			const file_lines = fs.readFileSync(entry_path, 'utf8').split('\n');
			let has_all_tags = true;
			let has_excluded_tags = false;
			let check_true = {};
			let check_false = {};
			for (const line of file_lines) {
				for (const tag of tags_to_match) {
					if (line.match(regex)?.some((t) => t.trim() === tag)) {
						check_true[tag] = true;
					}
				}
				for (const tag of tags_to_exclude) {
					if (line.match(regex)?.some((t) => t.trim() === tag)) {
						check_false[tag] = true;
						break;
					}
				}
			}
			has_all_tags = Object.keys(check_true).length === tags_to_match.length;
			has_excluded_tags = Object.keys(check_false).length > 0;
			if (has_all_tags && !has_excluded_tags) {
				matches.push(entry_path);
			}
		}
	}

	return matches;
}

const init = async () => {
	const server = Hapi.server({
		port: 3030,
		host: '127.0.0.1',
		routes: {
			files: {
				relativeTo: path.join(__dirname, 'public'),
			},
		},
	});
	await server.register(require('@hapi/inert'));

	server.route({
		method: 'GET',
		path: '/{param*}',
		handler: {
			directory: {
				path: '.',
				redirectToSlash: true,
			},
		},
	});

	server.route({
		method: 'GET',
		path: '/',
		handler: (_, h) => {
			return 'Hello Simple Markdown Preview!';
		},
	});

	server.route({
		method: 'POST',
		path: '/indicator',
		handler: (request, _) => {
			let payload = request.payload;
			global_indicator = Number(payload.indicator);
			return 'OK';
		},
	});
	server.route({
		method: 'POST',
		path: '/urltitle',
		handler: async (request, h) => {
			let payload = request.payload;
			let url = payload.url;
			//get the title of a url
			//https://stackoverflow.com/questions/36572540/nodejs-get-web-page-title
			try {
				const options = {
					timeout: 5000,
				};
				const { payload } = await Wreck.get(url, options);
				const $ = Cheerio.load(payload.toString());
				const title = $('title').text();
				return title;
			} catch (err) {
				if (err.isBoom && err.output.statusCode === 504) {
					return 'Timeout 5sec';
				} else {
					console.error(err);
					return h.response('Error fetching title').code(500);
				}
			}
		},
	});
	server.route({
		method: 'GET',
		path: '/preview',
		handler: (request, h) => {
			let fn_key = request.query.fn_key;

			let update_key = findKeyByValue(update_key_stores, fn_key);
			let md_cache = string_stores[fn_key];
			if (md_cache) {
				chartJs_codes = {};
				const html = marked.parse(md_cache.string);
				const resp_html =
					'<head>' +
					getStylesheet() +
					'</head>' +
					indicator(-1) +
					'<article class="markdown-body">\n' +
					html +
					getNavigationDiv(fn_key, true) +
					'</article>' +
					getSmoothScrollScript(
						update_key,
						md_cache.pos[0],
						md_cache.thisline.trim(),
						global_indicator < 0 ? smpConfig.show_indicator : global_indicator === 0 ? false : true,
					) +
					getChartJsScript() +
					copyright;
				return h.response(resp_html);
			} else {
				return h.response('Not found');
			}
		},
	});

	function replacePath(path, newFolder) {
		let newPath = path.replace(/\/SMP_MD_HOME\//, newFolder);

		return newPath;
	}
	server.route({
		method: 'GET',
		path: '/get_fn_key',
		handler: (_, h) => {
			return h.response({ fn_key: encodeURIComponent(current_fn_key) });
		},
	});
	server.route({
		method: 'GET',
		path: '/getupdate/{update_key}/{ts}',
		handler: (request, h) => {
			let { update_key, ts } = request.params;
			function getResponse() {
				let use_indicator =
					global_indicator < 0 ? smpConfig.show_indicator : global_indicator === 0 ? false : true;
				let fn_key = update_key_stores[update_key];
				let md_cache = string_stores[fn_key];
				if (md_cache) {
					if (md_cache.ts !== Number(ts)) {
						if (md_cache.touched[0]) {
							const html = marked.parse(md_cache.string);
							console.log(html);
							return h.response({
								code: 'touched_all',
								html: html + getNavigationDiv(fn_key, true),
								linenr: md_cache.pos[0],
								thisline: md_cache.thisline.trim(),
								ts: md_cache.ts,
								use_indicator: use_indicator,
							});
						} else if (md_cache.touched[1]) {
							return h.response({
								code: 'touched_line',
								linenr: md_cache.pos[0],
								thisline: md_cache.thisline.trim(),
								ts: md_cache.ts,
								use_indicator: use_indicator,
							});
						} else {
							return h.response({
								code: 'touched_none',
								ts: md_cache.ts,
								use_indicator: use_indicator,
							});
						}
					} else {
						return h.response({ code: 'notouch' });
					}
				} else {
					return h.response({ code: 'nocache' });
				}
			}

			return getResponse();
		},
	});
	server.route({
		method: 'GET',
		//this path pattern is generated from Wiki Link: [[myKey]]
		path: '/zettel',
		handler: (request, h) => {
			// Compile
			// let fn = fn_stores[request.query.myKey];
			let fn = request.query.path;
			//fn = replacePath(fn, smpConfig.home);
			const fileExists = fs.existsSync(fn);
			function isMarkdownFile(filePath) {
				const fileExtension = filePath.split('.').pop();
				return fileExtension === 'md';
			}
			function getDispositionType(fileName) {
				// Specify file types that can be displayed inline in the browser
				const inlineFileTypes = ['png', 'jpeg', 'jpg', 'pdf', 'gif', 'svg', 'webp', 'bmp'];

				const contentType = mime.lookup(fileName);
				const fileExtension = mime.extension(contentType);

				// Check if the file extension is in the list of inline file types
				if (fileExtension && inlineFileTypes.includes(fileExtension)) {
					return 'inline';
				} else {
					return 'attachment';
				}
			}
			if (fileExists) {
				if (!isMarkdownFile(fn)) {
					const fileName = path.basename(fn);
					const encodedFileName = encodeURIComponent(fileName);
					return h
						.file(fn, { confine: false })
						.header('Content-Type', mime.lookup(fileName))
						.header(
							'Content-Disposition',
							`${getDispositionType(fileName)}; filename*=UTF-8''${encodedFileName}`,
						);
				} else {
					const content = fs.readFileSync(fn, 'utf8');
					const structure = getStructureFromContent(smpConfig.home, fn, content);
					const lines = content.split(/\r?\n/);
					const patched = patchAllLines(lines, path.dirname(fn), fn, structure);
					const md_string = patched.join('\n');
					const html = marked.parse(md_string);

					return h.response(
						getStylesheet() +
							'<article class="markdown-body">' +
							html +
							getNavigationDiv(fn, false) +
							'</article>' +
							copyright,
					);
				}
			} else {
				return h.response(
					'Not found. <br/>You may edit your MD normally, and refresh this page later.',
				);
			}
		},
	});

	server.route({
		method: 'GET',
		//this path pattern is generated from Wiki Link: [[myKey]]
		path: '/tag',
		handler: (request, h) => {
			const tag = request.query.tag;
			const fn = request.query.fn;
			const tagged_files = search_tag_in_directory(smpConfig.home, [tag], []);
			console.log(tagged_files);
			let html = '';
			for (let i = 0; i < tagged_files.length; i++) {
				(html +=
					"<div><a href='/zettel?path=" +
					encodeURIComponent(tagged_files[i]) +
					"'>" +
					path.basename(tagged_files[i], '.md')),
					'</a></div>';
			}
			return h.response(
				getStylesheet() +
					'<article class="markdown-body">' +
					`<h1>${tag}</h1>` +
					html +
					'</article>' +
					copyright,
			);
		},
	});
	server.route({
		method: 'GET',
		//this path pattern is generated from Wiki Link: [[myKey]]
		path: '/editThis',
		handler: (request, h) => {
			// Compile
			// let fn = fn_stores[request.query.myKey];
			let fn = request.query.path;
			//fn = replacePath(fn, smpConfig.home);
			logToFile('editThis: ' + fn);
			const fileExists = fs.existsSync(fn);
			function isMarkdownFile(filePath) {
				const fileExtension = filePath.split('.').pop();
				return fileExtension === 'md';
			}
			if (fileExists && isMarkdownFile(fn)) {
				console.log(smpConfig.tmpdir);
				fs.writeFile(
					path.join(smpConfig.tmpdir, '.smp.pipe'),
					`editit:${fn}:${Date.now()}`,
					(err) => {
						if (err) throw err;
						console.log('The file has been saved!');
					},
				);
				return h.response('Saved');
			}
		},
	});
	server.route({
		method: 'GET',
		//this path pattern is within previous output, which is a generate by marked from [name](./assets/....)
		path: '/zettel/{path}/{any*}',
		handler: (request, h) => {
			let fn = path.join(smpConfig.home, request.params.path, request.params.any);
			return h.file(fn, { confine: false });
		},
	});
	server.route({
		method: 'POST',
		path: '/config',
		handler: (request, h) => {
			let payload = request.payload;
			if (payload.cssfile) {
				if (fs.existsSync(payload.cssfile)) {
					smpConfig.css = `http://127.0.0.1:3030/SMP_LINK/${Buffer.from(payload.cssfile).toString(
						'base64',
					)}`;
				} else {
					smpConfig.css = defaultMarkDownCss;
				}
			}
			const keys = ['snippets_folder', 'home', 'show_indicator', 'tmpdir'];
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				smpConfig[key] = payload[key];
			}
			if (smpConfig.home && smpConfig.home.endsWith('/') === false) {
				smpConfig.home += '/';
			}
			logToFile('config updated: ' + JSON.stringify(smpConfig, null, 2));
			return h.response('config updated');
		},
	});
	server.route({
		method: 'POST',
		path: '/update',
		handler: (request, h) => {
			let payload = request.payload;
			let fn = payload.fn;
			let lines = payload.lines;
			if (smpConfig.show_navigation_content) {
				lines = lines.concat([
					'<div id="smp_nav_container">',
					'',
					'## Tags',
					'',
					'{tags}',
					'',
					'## Links',
					'',
					'{links}',
					'',
					'## Backlinks',
					'',
					'{backlinks}',
					'',
					'</div>',
				]);
			}
			let fn_key = payload.fn_key;
			if (!fn_key || !fn) {
				payload.lines.splice(1, payload.lines.length - 1, '...');
				logToFile('fn_key is undefined, bypass update ' + JSON.stringify(payload));
				return h.response('fn_key is undefined, bypass update');
			}
			fn_key = decodeURIComponent(fn_key);
			let update_key = findKeyByValue(update_key_stores, fn_key);
			if (!update_key) {
				update_key_stores[generateRandomString(16)] = fn_key;
			}
			if (lines.length > 0 && lines[0] !== 'NO_CHANGE') {
				//update content
				const structure = getStructureFromContent(smpConfig.home, fn_key, lines.join('\n'));
				let patched = patchAllLines(lines, path.dirname(fn), fn, structure);
				let md_string = patched.join('\n');
				string_stores[fn_key] = {
					string: md_string,
					pos: payload.pos,
					fn: payload.fn,
					fn_key: payload.fn_key,
					thisline: payload.thisline,
					touched: [true, true], //touch content and linenr
					ts: new Date().getTime(),
				};
				current_fn_key = fn_key;
				logToFile(
					'Update content:\t' + current_fn_key + ' , pos to :' + JSON.stringify(payload.pos),
				);
				//TODO: must update without defer
			} else {
				current_fn_key = fn_key;
				logToFile(
					'Update position:\t' + current_fn_key + ' , pos to: ' + JSON.stringify(payload.pos),
				);
				let store = string_stores[fn_key];
				if (store) {
					string_stores[fn_key] = {
						string: store.string,
						pos: payload.pos,
						fn: payload.fn,
						fn_key: fn_key,
						thisline: payload.thisline,
						touched: [false, true], //touch linenr only
						ts: new Date().getTime(),
					};
				}
			}
			let ret = `Bufnr: ${payload.bufnr}, Pos: ${payload.pos}, Stores: ${
				Object.keys(string_stores).length
			} `;
			const response = h.response(ret);
			response.header('Connection', 'keep-alive');
			return response;
		},
	});
	server.route({
		method: 'POST',
		path: '/stop',
		handler: (request, h) => {
			logToFile('Receive stop request, stop now!!!');
			setTimeout(() => {
				process.exit(1);
			}, 1000);
			return 'Stopped';
		},
	});

	await server.start();
	logToFile('Server running on ' + server.info.uri);
};

process.on('unhandledRejection', (err) => {
	console.log(err);
	process.exit(1);
});

init();
